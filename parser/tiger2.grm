structure A = Absyn

%%
%term
    EOF
  | ID of string
  | INT of int | STRING of string
  | COMMA | COLON | SEMICOLON | LPAREN | RPAREN | LBRACK | RBRACK
  | LBRACE | RBRACE | DOT
  | PLUS | MINUS | UMINUS | TIMES | DIVIDE | EQ | NEQ | LT | LE | GT | GE
  | AND | OR | ASSIGN
  | ARRAY | IF | THEN | ELSE | WHILE | FOR | TO | DO | LET | IN | END | OF
  | BREAK | NIL
  | FUNCTION | VAR | TYPE

%nonterm  exp of A.exp | expList of (A.exp*pos) list
| expTail of (A.exp*pos) -> (A.exp*pos) list
| program of A.exp | fundec | dec | tydec
| vardec | ty | arrty | recty | fieldec | let | arrCreate
| field | recCreate | lvalue | decList
| ltail | funcall | funArgs
| flist of (A.symbol*A.exp*pos) list
| flistTail of (A.symbol*A.exp*pos) -> (A.symbol*A.exp*pos) list

%pos int
%verbose
%start program
%eop EOF
%noshift EOF

%name Tiger

%keyword WHILE FOR TO BREAK LET IN END FUNCTION VAR TYPE ARRAY IF THEN ELSE
	DO OF NIL

%prefer THEN ELSE LPAREN

%value ID ("bogus")
%value INT (1)
%value STRING ("")

%nonassoc ASSIGN DO OF
%nonassoc ELSE
%nonassoc THEN
%nonassoc SEMICOLON
%nonassoc AND OR
%nonassoc EQ NEQ LT LE GT GE
%left PLUS MINUS
%left TIMES DIVIDE
%nonassoc UMINUS

%%

(* This is a skeleton grammar file, meant to illustrate what kind of
 * declarations are necessary above the %% mark.  Students are expected
 *  to replace the two dummy productions below with an actual grammar.
 *)

program	: exp			(PrintAbsyn.print (TextIO.stdOut, exp1); exp1)

exp: LPAREN exp RPAREN			(exp1)
exp: LPAREN expList RPAREN			(A.SeqExp expList1)
expList: exp SEMICOLON exp expTail			(expTail1 (exp1, exp1left:pos))
expTail: SEMICOLON exp expTail (fn (e:A.exp, pos:pos) => (e, pos)::expTail1 (exp1, exp1left))
expTail: (fn (e:A.exp, pos:pos) => (e, pos)::[])

exp: INT          (A.IntExp INT)
exp: STRING       (A.StringExp(STRING, STRINGleft))
exp: exp PLUS exp (A.OpExp{left=exp1, oper=A.PlusOp, right=exp2, pos=exp1left:pos})
exp: exp MINUS exp (A.OpExp{left=exp1, oper=A.MinusOp, right=exp2, pos=exp1left:pos})
exp: exp TIMES exp (A.OpExp{left=exp1, oper=A.TimesOp, right=exp2, pos=exp1left:pos})
exp: exp DIVIDE exp (A.OpExp{left=exp1, oper=A.DivideOp, right=exp2, pos=exp1left:pos})
exp: exp AND exp (A.IfExp{test=exp1, then'=exp2, else'=SOME (A.IntExp 0), pos=exp1left})
exp: exp OR exp (A.IfExp{test=exp1, then'=A.IntExp 1, else'=SOME exp2, pos=exp1left})
exp: exp EQ exp (A.OpExp{left=exp1, oper=A.EqOp, right=exp2, pos=exp1left:pos})
exp: exp NEQ exp (A.OpExp{left=exp1, oper=A.NeqOp, right=exp2, pos=exp1left:pos})
exp: exp LT exp (A.OpExp{left=exp1, oper=A.LtOp, right=exp2, pos=exp1left:pos})
exp: exp LE exp (A.OpExp{left=exp1, oper=A.LeOp, right=exp2, pos=exp1left:pos})
exp: exp GT exp (A.OpExp{left=exp1, oper=A.GtOp, right=exp2, pos=exp1left:pos})
exp: exp GE exp (A.OpExp{left=exp1, oper=A.GeOp, right=exp2, pos=exp1left:pos})
exp: IF exp THEN exp (A.IfExp{test=exp1, then'=exp2, else'=NONE, pos=exp1left})
exp: IF exp THEN exp ELSE exp (A.IfExp{test=exp1, then'=exp2, else'=SOME(exp3), pos=exp1left})
exp: NIL (A.NilExp)
exp: LPAREN RPAREN (A.NilExp)
exp: BREAK (A.BreakExp BREAKleft)
exp: WHILE exp DO exp (A.WhileExp{test=exp1, body=exp2,pos=exp1left})
exp: MINUS exp %prec UMINUS (A.OpExp{left=(A.IntExp 0), oper=A.MinusOp, right=exp1, pos=exp1left})

flist: ID EQ exp flistTail (flistTail1 (Symbol.symbol ID1, exp1, ID1left:pos))
flist: ([])
flistTail: COMMA ID EQ exp flistTail (fn (s:A.symbol, e:A.exp, pos) => (s,e,pos)::flistTail1(Symbol.symbol ID1, exp1, ID1left:pos))
flistTail: (fn (s:A.symbol, e:A.exp, pos) => (s,e,pos)::[])
