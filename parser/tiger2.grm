structure A = Absyn

%%
%term
    EOF
  | ID of string
  | INT of int | STRING of string
  | COMMA | COLON | SEMICOLON | LPAREN | RPAREN | LBRACK | RBRACK
  | LBRACE | RBRACE | DOT
  | PLUS | MINUS | UMINUS | TIMES | DIVIDE | EQ | NEQ | LT | LE | GT | GE
  | AND | OR | ASSIGN
  | ARRAY | IF | THEN | ELSE | WHILE | FOR | TO | DO | LET | IN | END | OF
  | BREAK | NIL
  | FUNCTION | VAR | TYPE

  %nonterm program      of A.exp
         | exp          of A.exp
         | expList      of (A.exp*pos) list
         | expTail      of (A.exp*pos) -> (A.exp*pos) list
         | dec          of A.dec
         | decList      of A.dec list
         | typeDec        of A.dec
         | ty           of A.ty
         | arrty        of A.ty
         | recty        of A.ty
         | varDec       of A.dec
         | fieldList     of A.field list
         | fieldListTail of A.field -> A.field list
         | functionDec       of A.dec
         | field        of A.field
         | flist        of (A.symbol*A.exp*pos) list
         | flistTail    of (A.symbol*A.exp*pos) -> (A.symbol*A.exp*pos) list
         | funArgs      of A.exp list
         | funArgsTail  of A.exp list
         | lvalue       of A.var
         | ltail        of A.var -> A.var

%pos int
%verbose
%start program
%eop EOF
%noshift EOF

%name Tiger

%keyword WHILE FOR TO BREAK LET IN END FUNCTION VAR TYPE ARRAY IF THEN ELSE
	DO OF NIL

%prefer THEN ELSE LPAREN

%value ID ("bogus")
%value INT (1)
%value STRING ("")

%nonassoc ASSIGN DO OF
%nonassoc ELSE
%nonassoc THEN
%nonassoc SEMICOLON
%nonassoc AND OR
%nonassoc EQ NEQ LT LE GT GE
%left PLUS MINUS
%left TIMES DIVIDE
%nonassoc UMINUS

%%

(* This is a skeleton grammar file, meant to illustrate what kind of
 * declarations are necessary above the %% mark.  Students are expected
 *  to replace the two dummy productions below with an actual grammar.
 *)

program	: exp			(PrintAbsyn.print (TextIO.stdOut, exp1); exp1)

exp: LPAREN exp RPAREN			(exp1)
exp: LPAREN expList RPAREN			(A.SeqExp expList1)
expList: exp SEMICOLON exp expTail			(expTail1 (exp1, exp1left:pos))
expTail: SEMICOLON exp expTail (fn (e:A.exp, pos:pos) => (e, pos)::expTail1 (exp1, exp1left))
expTail: (fn (e:A.exp, pos:pos) => (e, pos)::[])

exp: INT          (A.IntExp INT)
exp: STRING       (A.StringExp(STRING, STRINGleft))
exp: exp PLUS exp (A.OpExp{left=exp1, oper=A.PlusOp, right=exp2, pos=exp1left:pos})
exp: exp MINUS exp (A.OpExp{left=exp1, oper=A.MinusOp, right=exp2, pos=exp1left:pos})
exp: exp TIMES exp (A.OpExp{left=exp1, oper=A.TimesOp, right=exp2, pos=exp1left:pos})
exp: exp DIVIDE exp (A.OpExp{left=exp1, oper=A.DivideOp, right=exp2, pos=exp1left:pos})
exp: exp AND exp (A.IfExp{test=exp1, then'=exp2, else'=SOME (A.IntExp 0), pos=exp1left})
exp: exp OR exp (A.IfExp{test=exp1, then'=A.IntExp 1, else'=SOME exp2, pos=exp1left})
exp: exp EQ exp (A.OpExp{left=exp1, oper=A.EqOp, right=exp2, pos=exp1left:pos})
exp: exp NEQ exp (A.OpExp{left=exp1, oper=A.NeqOp, right=exp2, pos=exp1left:pos})
exp: exp LT exp (A.OpExp{left=exp1, oper=A.LtOp, right=exp2, pos=exp1left:pos})
exp: exp LE exp (A.OpExp{left=exp1, oper=A.LeOp, right=exp2, pos=exp1left:pos})
exp: exp GT exp (A.OpExp{left=exp1, oper=A.GtOp, right=exp2, pos=exp1left:pos})
exp: exp GE exp (A.OpExp{left=exp1, oper=A.GeOp, right=exp2, pos=exp1left:pos})
exp: IF exp THEN exp (A.IfExp{test=exp1, then'=exp2, else'=NONE, pos=exp1left})
exp: IF exp THEN exp ELSE exp (A.IfExp{test=exp1, then'=exp2, else'=SOME(exp3), pos=exp1left})
exp: NIL (A.NilExp)
exp: LPAREN RPAREN (A.NilExp)
exp: BREAK (A.BreakExp BREAKleft)
exp: WHILE exp DO exp (A.WhileExp{test=exp1, body=exp2,pos=exp1left})
exp: MINUS exp %prec UMINUS (A.OpExp{left=(A.IntExp 0), oper=A.MinusOp, right=exp1, pos=exp1left})
exp: ID LBRACE flist RBRACE  (A.RecordExp {fields= flist1, typ= Symbol.symbol ID1, pos=ID1left})
exp: LET decList IN exp END             (A.LetExp {decs=decList, body=exp, pos=LETleft:pos})
exp: FOR ID ASSIGN exp TO exp DO exp    (A.ForExp {var=Symbol.symbol ID, escape=ref false, lo=exp1,hi=exp2,body=exp3,pos=FORleft:pos})
| lvalue ASSIGN exp                  (A.AssignExp{var=lvalue1, exp=exp1, pos=lvalue1left})

flist: ID EQ exp flistTail (flistTail1 (Symbol.symbol ID1, exp1, ID1left:pos))
flist: ([])
flistTail: COMMA ID EQ exp flistTail (fn (s:A.symbol, e:A.exp, pos) => (s,e,pos)::flistTail1(Symbol.symbol ID1, exp1, ID1left:pos))
flistTail: (fn (s:A.symbol, e:A.exp, pos) => (s,e,pos)::[])

decList: dec decList                    (dec1 :: decList1)
       |                                ([])

dec: typeDec             (typeDec1)
   | functionDec         (functionDec1)
   | varDec              (varDec1)

varDec: VAR ID COLON ID ASSIGN exp      (A.VarDec {name= Symbol.symbol ID1, typ= SOME (Symbol.symbol ID2, ID2left:pos), init= exp1, pos=ID1left, escape= ref false})
      | VAR ID ASSIGN exp               (A.VarDec {name= Symbol.symbol ID1, typ= NONE, init= exp1, pos=ID1left, escape= ref false})

typeDec: TYPE ID EQ ty                  (A.TypeDec ({name= Symbol.symbol ID1, ty=ty1, pos=ID1left:pos}::[]))

ty: ID                                  (A.NameTy (Symbol.symbol ID1, ID1left))
| ARRAY OF ID                           (A.ArrayTy (Symbol.symbol ID1, ID1left:pos))
| LBRACE fieldList RBRACE               (A.RecordTy fieldList1)
| LBRACE RBRACE                         (A.RecordTy [])

fieldList: ID COLON ID fieldListTail              (fieldListTail1 {name=Symbol.symbol ID1, typ=Symbol.symbol ID2, pos=ID1left, escape=ref false})
fieldListTail: COMMA ID COLON ID fieldListTail    (fn f:A.field => f::fieldListTail1 {name=Symbol.symbol ID1, typ=Symbol.symbol ID2, pos=ID1left, escape=ref false})
             |                                    (fn f:A.field => f::[])

functionDec: FUNCTION ID LPAREN fieldList RPAREN COLON ID EQ exp   (A.FunctionDec({name=Symbol.symbol ID1, params=fieldList, result=SOME (Symbol.symbol ID2, ID2left:pos), body=exp1, pos=ID1left}::[]))
           | FUNCTION ID LPAREN RPAREN COLON ID EQ exp            (A.FunctionDec({name=Symbol.symbol ID1, params=[], result=SOME (Symbol.symbol ID2, ID2left:pos), body=exp1, pos=ID1left}::[]))
           | FUNCTION ID LPAREN fieldList RPAREN EQ exp            (A.FunctionDec({name=Symbol.symbol ID1, params=fieldList, result=NONE, body=exp1, pos=ID1left}::[]))
           | FUNCTION ID LPAREN RPAREN EQ exp                     (A.FunctionDec({name=Symbol.symbol ID1, params=[], result=NONE, body=exp1, pos=ID1left}::[]))

lvalue: ID ltail                                             (ltail1 (A.SimpleVar (Symbol.symbol ID1, ID1left)))

ltail: LBRACK exp RBRACK ltail                               (fn x:A.var => ltail1 (A.SubscriptVar(x, exp1, exp1left)))
     | DOT ID ltail                                          (fn x:A.var => ltail1 (A.FieldVar(x, Symbol.symbol ID1, ID1left)))
     |                                                       (fn x => x)
