structure A = Absyn

%%
%term
    EOF
  | ID of string
  | INT of int | STRING of string
  | COMMA | COLON | SEMICOLON | LPAREN | RPAREN | LBRACK | RBRACK
  | LBRACE | RBRACE | DOT
  | PLUS | MINUS | UMINUS | TIMES | DIVIDE | EQ | NEQ | LT | LE | GT | GE
  | AND | OR | ASSIGN
  | ARRAY | IF | THEN | ELSE | WHILE | FOR | TO | DO | LET | IN | END | OF
  | BREAK | NIL
  | FUNCTION | VAR | TYPE

(* Each nonterm needs to match a datatype in Absyn,
   every nonterm of type A.exp is unnecessary and can be put under the exp nonterm (except program and exp),
   THESE NEED TO BE CHECKED FOR ACCURACY *)

%nonterm program      of A.exp
       | exp          of A.exp
       | expList      of (A.exp*pos) list
       | expTail      of (A.exp*pos) -> (A.exp*pos) list
       | dec          of A.dec
       | decList      of A.dec list
       | tyDec        of A.dec list
       | ty           of A.ty
       | arrty        of A.ty
       | recty        of A.ty
       | vardec       of A.dec
       | fieldDec     of A.field
       | funDec       of A.dec list
       | field        of A.field
       | flist        of (A.symbol*A.exp*pos) list
       | flistTail    of (A.symbol*A.exp*pos) -> (A.symbol*A.exp*pos) list
       | funArgs      of A.exp list
       | funArgsTail  of A.exp list
       | lvalue       of A.var
       | ltail        of A.var -> A.var

%pos int
%verbose
%start program
%eop EOF
%noshift EOF

%name Tiger

%keyword WHILE FOR TO BREAK LET IN END FUNCTION VAR TYPE ARRAY IF THEN ELSE DO OF NIL

%prefer THEN ELSE LPAREN

%value ID ("bogus")
%value INT (1)
%value STRING ("")

%nonassoc ASSIGN DO OF
(* %left COMMA *)
%nonassoc ELSE
%nonassoc THEN
%nonassoc SEMICOLON
%nonassoc AND OR
%nonassoc EQ NEQ LT LE GT GE
%left PLUS MINUS
%left TIMES DIVIDE
%left UMINUS

%%

program: exp			        (PrintAbsyn.print (TextIO.stdOut, exp1); exp1)

exp: LPAREN exp RPAREN		        (exp1)
   | LPAREN expList RPAREN	        (A.SeqExp expList1)

expList: exp SEMICOLON exp expTail			(expTail1 (exp1, exp1left:pos))
expTail: SEMICOLON exp expTail (fn (e:A.exp, pos:pos) => (e, pos)::expTail1 (exp1, exp1left))
   | (fn (e:A.exp, pos:pos) => (e, pos)::[])

exp: INT                                (A.IntExp INT)
   | STRING                             (A.StringExp(STRING, STRINGleft))
   | exp PLUS exp                       (A.OpExp{left=exp1, oper=A.PlusOp, right=exp2, pos=exp1left:pos})
   | exp MINUS exp                      (A.OpExp{left=exp1, oper=A.MinusOp, right=exp2, pos=exp1left:pos})
   | exp TIMES exp                      (A.OpExp{left=exp1, oper=A.TimesOp, right=exp2, pos=exp1left:pos})
   | exp DIVIDE exp                     (A.OpExp{left=exp1, oper=A.DivideOp, right=exp2, pos=exp1left:pos})
   | exp AND exp                        (A.IfExp{test=exp1, then'=exp2, else'=SOME (A.IntExp 0), pos=exp1left})
   | exp OR exp                         (A.IfExp{test=exp1, then'=A.IntExp 1, else'=SOME exp2, pos=exp1left})
   | exp EQ exp                         (A.OpExp{left=exp1, oper=A.EqOp, right=exp2, pos=exp1left:pos})
   | exp NEQ exp                        (A.OpExp{left=exp1, oper=A.NeqOp, right=exp2, pos=exp1left:pos})
   | exp LT exp                         (A.OpExp{left=exp1, oper=A.LtOp, right=exp2, pos=exp1left:pos})
   | exp LE exp                         (A.OpExp{left=exp1, oper=A.LeOp, right=exp2, pos=exp1left:pos})
   | exp GT exp                         (A.OpExp{left=exp1, oper=A.GtOp, right=exp2, pos=exp1left:pos})
   | exp GE exp                         (A.OpExp{left=exp1, oper=A.GeOp, right=exp2, pos=exp1left:pos})
   | IF exp THEN exp                    (A.IfExp{test=exp1, then'=exp2, else'=NONE, pos=exp1left})
   | IF exp THEN exp ELSE exp           (A.IfExp{test=exp1, then'=exp2, else'=SOME(exp3), pos=exp1left})
   | NIL                                (A.NilExp)
   | LPAREN RPAREN                      (A.NilExp)
   | lvalue ASSIGN exp                  (A.AssignExp{var=lvalue1, exp=exp1, pos=lvalue1left})
   | BREAK                              (A.BreakExp BREAKleft)
   | WHILE exp DO exp                   (A.WhileExp{test=exp1, body=exp2,pos=exp1left})
   | MINUS exp %prec UMINUS             (A.OpExp{left=(A.IntExp 0), oper=A.MinusOp, right=exp1, pos=exp1left})
   | lvalue                             (A.var lvalue1)
   | ID LBRACK exp RBRACK OF exp        (A.ArrayExp {typ=ID1, size=exp1, init=exp2, pos=IDleft})
   | ID LBRACE flist RBRACE             () (* recCreate  *)
   | ID LPAREN funArgs RPAREN           (A.CallExp{func=ID, args=funArgs,pos=IDleft}) (* funCall *)
   | FOR ID ASSIGN exp TO exp DO exp    ()
   | LET decList IN exp END             ()
   | LET decList IN END                 ()

dec: tyDec                              ()
   | funDec                             ()
   | vardec                             ()

decList: dec decList                    (fn )
       |                                (fn d:A.dec => d::[])

tyDec: TYPE ID EQ ty                    ((A.TypeDec {name: Symbol.symbol ID1, ty:ty1,pos:ID1left})::[])

ty: ID                                  ()
  | arrty                               ()
  | recty                               ()

arrty: ARRAY OF ID                      ()

recty: LBRACE fieldDec RBRACE           ()
     | LBRACE RBRACE                    ()

vardec: VAR ID COLON ID ASSIGN exp      (A.VarDec {name: Symbol.symbol ID1, typ: SOME (Symbol.symbol ID2, ID2left), init: exp1, pos:ID1LEFT, escape: false})
      | VAR ID ASSIGN exp               (A.VarDec {name: Symbol.symbol ID1, typ: NONE, init: exp1, pos:ID1left, escape: false})

fieldDec: fieldDec COMMA fieldDec       ()
        | ID COLON ID                   ()

funDec: FUNCTION ID LPAREN fieldDec RPAREN COLON ID EQ exp   ()
      | FUNCTION ID LPAREN RPAREN COLON ID EQ exp            ()
      | FUNCTION ID LPAREN fieldDec RPAREN EQ exp            ()
      | FUNCTION ID LPAREN RPAREN EQ exp                     ()

field: ID EQ exp                                             ()
     | field COMMA field                                     ()

flist: ID EQ exp flistTail                                   (flistTail1 (Symbol.symbol ID1, exp1, ID1left:pos))
     |                                                       (fn (s:A.symbol, e:A.exp, pos) => (s,e,pos)::[])

flistTail: COMMA ID EQ exp flistTail                         (fn (s:A.symbol, e:A.exp, pos) => (s,e,pos)::flistTail1(Symbol.symbol ID1, exp1, ID1left:pos))
         |                                                   (fn (s:A.symbol, e:A.exp, pos) => (s,e,pos)::[])

funArgs: exp funArgsTail                                     (exp::funArgsTail)
       |                                                     ()

funArgsTail: COMMA exp funArgsTail                           (exp::funArgsTail)
           |                                                 ()

lvalue: ID ltail                                             (ltail1 (A.SimpleVar (Symbol.symbol ID1, ID1left)))

ltail: LBRACK exp RBRACK ltail                               (fn x:A.var => ltail1 (A.SubscriptVar(x, exp1, exp1left)))
     | DOT ID ltail                                          (fn x:A.var => ltail1 (A.FieldVar(x, Symbol.symbol ID1, ID1left)))
     |                                                       (fn x => x)
