structure A = Absyn

%%
%term
    EOF
  | ID of string
  | INT of int | STRING of string
  | COMMA | COLON | SEMICOLON | LPAREN | RPAREN | LBRACK | RBRACK
  | LBRACE | RBRACE | DOT
  | PLUS | MINUS | UMINUS | TIMES | DIVIDE | EQ | NEQ | LT | LE | GT | GE
  | AND | OR | ASSIGN
  | ARRAY | IF | THEN | ELSE | WHILE | FOR | TO | DO | LET | IN | END | OF
  | BREAK | NIL
  | FUNCTION | VAR | TYPE

%nonterm  exp of A.exp | expList of (A.exp * pos) list | program of A.exp | fundec | dec | tydec
| vardec | ty | arrty | recty | fieldec | let
| field | recCreate | lvalue of (A.var) | decList
| ltail | funcall | funArgs | typeDec of A.TypeDec | tytail of A.TypeDec option
| funDec of A.FunctionDec| ftail of A.fundec option

%pos int
%verbose
%start program
%eop EOF
%noshift EOF

%name Tiger

%keyword WHILE FOR TO BREAK LET IN END FUNCTION VAR TYPE ARRAY IF THEN ELSE
	DO OF NIL

%prefer THEN ELSE LPAREN

%value ID ("bogus")
%value INT (1)
%value STRING ("")

%nonassoc ASSIGN DO OF
(* %left COMMA *)
%nonassoc ELSE
%nonassoc THEN
%nonassoc SEMICOLON
%nonassoc AND OR
%nonassoc EQ NEQ LT LE GT GE
%left PLUS MINUS
%left TIMES DIVIDE
%left UMINUS

%%

(* This is a skeleton grammar file, meant to illustrate what kind of
 * declarations are necessary above the %% mark.  Students are expected
 *  to replace the two dummy productions below with an actual grammar.
 *)

program	: exp			(exp1)

exp: LPAREN exp RPAREN			(exp1)
exp: LPAREN expList RPAREN			(A.SeqExp expList1)
expList: exp SEMICOLON exp			((exp1,exp1left:pos)::(exp2,exp2left:pos)::[])
expList: expList SEMICOLON exp ((exp1,exp1left:pos)::(expList1))

exp: INT          (A.IntExp INT)
exp: STRING       (A.StringExp(STRING, STRINGleft))
exp: exp PLUS exp (A.OpExp{left=exp1, oper=A.PlusOp, right=exp2, pos=exp1left:pos})
exp: exp MINUS exp (A.OpExp{left=exp1, oper=A.MinusOp, right=exp2, pos=exp1left:pos})
exp: exp TIMES exp (A.OpExp{left=exp1, oper=A.TimesOp, right=exp2, pos=exp1left:pos})
exp: exp DIVIDE exp (A.OpExp{left=exp1, oper=A.DivideOp, right=exp2, pos=exp1left:pos})
exp: exp AND exp (A.IfExp{test=exp1, then'=exp2, else'=SOME (A.IntExp 0), pos=exp1left})
exp: exp OR exp (A.IfExp{test=exp1, then'=A.IntExp 1, else'=SOME exp2, pos=exp1left})
exp: exp EQ exp (A.OpExp{left=exp1, oper=A.EqOp, right=exp2, pos=exp1left:pos})
exp: exp NEQ exp (A.OpExp{left=exp1, oper=A.NeqOp, right=exp2, pos=exp1left:pos})
exp: exp LT exp (A.OpExp{left=exp1, oper=A.LtOp, right=exp2, pos=exp1left:pos})
exp: exp LE exp (A.OpExp{left=exp1, oper=A.LeOp, right=exp2, pos=exp1left:pos})
exp: exp GT exp (A.OpExp{left=exp1, oper=A.GtOp, right=exp2, pos=exp1left:pos})
exp: exp GE exp (A.OpExp{left=exp1, oper=A.GeOp, right=exp2, pos=exp1left:pos})
exp: IF exp THEN exp (A.IfExp{test=exp1, then'=exp2, else'=NONE, pos=exp1left})
exp: IF exp THEN exp ELSE exp (A.IfExp{test=exp1, then'=exp2, else'=SOME(exp3), pos=exp1left})
exp: NIL (A.NilExp)
exp: LPAREN RPAREN (A.NilExp)
exp: lvalue ASSIGN exp (A.AssignExp{var=lvalue1, exp=exp1, pos=lvalue1left})
exp: BREAK (A.BreakExp BREAKleft)
exp: WHILE exp DO exp (A.WhileExp{test=exp1, body=exp2,pos=exp1left})
exp: MINUS exp %prec UMINUS (A.OpExp{left=(A.IntExp 0), oper=A.MinusOp, right=exp1, pos=exp1left})
exp: lvalue (A.var lvalue1)
exp: ID LBRACK exp RBRACK OF exp (A.ArrayExp {typ=ID1, size=exp1, init=exp2, pos=IDleft})
exp: recCreate ()
exp: funcall (funcall1)

exp: FOR ID ASSIGN exp TO exp DO exp ()
exp: let ()


let: LET decList IN exp END ()
let: LET decList IN END ()

decList: ()
decList: dec decList  ()

dec: typeDec  ()
dec: funDec ()
dec: vardec ()



tydec: TYPE ID EQ ty ()
ty: ID ()
ty: arrty ()
ty: recty ()
arrty: ARRAY OF ID ()
recty: LBRACE fieldec RBRACE  ()
recty: LBRACE RBRACE ()

vardec: VAR ID COLON ID ASSIGN exp ()
vardec: VAR ID ASSIGN exp ()

fieldec: fieldec COMMA fieldec ()
fieldec: ID COLON ID ()

fundec: FUNCTION ID LPAREN fieldec RPAREN COLON ID EQ exp ()
fundec: FUNCTION ID LPAREN RPAREN COLON ID EQ exp ()
fundec: FUNCTION ID LPAREN fieldec RPAREN EQ exp ()
fundec: FUNCTION ID LPAREN RPAREN EQ exp ()

field: ID EQ exp ()
field: field COMMA field ()

flist: ID EQ exp flistTail()
| ()
flistTail: COMMA ID EQ exp flistTail()
         | ()    

recCreate: ID LBRACE flist RBRACE ()

funcall: ID LPAREN RPAREN (A.CallExp{func=ID, args=[], pos=IDleft})
funcall: ID LPAREN exp RPAREN (A.CallExp{func=ID, args=exp::[], pos=IDleft})
funcall: ID LPAREN funArgs RPAREN (A.CallExp{func=ID, args=funArgs,pos=IDleft})
funArgs: exp COMMA exp ()
funArgs: funArgs COMMA exp ()

lvalue: ID ltail ()
ltail: LBRACK exp RBRACK ltail ()
ltail: DOT ID ltail()
ltail: ()
