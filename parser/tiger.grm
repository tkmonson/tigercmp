structure A = Absyn

%%
%term
    EOF
  | ID of string
  | INT of int | STRING of string
  | COMMA | COLON | SEMICOLON | LPAREN | RPAREN | LBRACK | RBRACK
  | LBRACE | RBRACE | DOT
  | PLUS | MINUS | UMINUS | TIMES | DIVIDE | EQ | NEQ | LT | LE | GT | GE
  | AND | OR | ASSIGN
  | ARRAY | IF | THEN | ELSE | WHILE | FOR | TO | DO | LET | IN | END | OF
  | BREAK | NIL
  | FUNCTION | VAR | TYPE

(* Each nonterm needs to match a datatype in Absyn,
   every nonterm of type A.exp is unnecessary and can be put under the exp nonterm (except program and exp),
   THESE NEED TO BE CHECKED FOR ACCURACY *)
	 
%nonterm program      of A.exp 
       | exp          of A.exp
       | expList      of (A.exp * pos) list
       | dec          of A.dec
       | decList      of A.dec list
       | tyDec        of A.dec list
       | ty           of A.ty
       | arrty        of A.ty
       | recty        of A.ty
       | vardec       of A.dec
       | fieldDec     of A.field
       | funDec       of A.dec list
       | field        of A.field
       | flist        of A.field list
       | flistTail    of A.field list
       | funArgs      of A.exp list
       | funArgsTail  of A.exp list 
       | lvalue       of A.var 
       | ltail        of A.var

%pos int
%verbose
%start program
%eop EOF
%noshift EOF

%name Tiger

%keyword WHILE FOR TO BREAK LET IN END FUNCTION VAR TYPE ARRAY IF THEN ELSE DO OF NIL

%prefer THEN ELSE LPAREN

%value ID ("bogus")
%value INT (1)
%value STRING ("")

%nonassoc ASSIGN DO OF
(* %left COMMA *)
%nonassoc ELSE
%nonassoc THEN
%nonassoc SEMICOLON
%nonassoc AND OR
%nonassoc EQ NEQ LT LE GT GE
%left PLUS MINUS
%left TIMES DIVIDE
%left UMINUS

%%

program: exp			        (exp1)

exp: LPAREN exp RPAREN		        (exp1)
   | LPAREN expList RPAREN	        (A.SeqExp expList1)
	 
expList: exp SEMICOLON exp	        ((exp1,exp1left:pos)::(exp2,exp2left:pos)::[])
       | expList SEMICOLON exp          ((exp1,exp1left:pos)::(expList1))

exp: INT                                (A.IntExp INT)
   | STRING                             (A.StringExp(STRING, STRINGleft))
   | exp PLUS exp                       (A.OpExp{left=exp1, oper=A.PlusOp, right=exp2, pos=exp1left:pos})
   | exp MINUS exp                      (A.OpExp{left=exp1, oper=A.MinusOp, right=exp2, pos=exp1left:pos})
   | exp TIMES exp                      (A.OpExp{left=exp1, oper=A.TimesOp, right=exp2, pos=exp1left:pos})
   | exp DIVIDE exp                     (A.OpExp{left=exp1, oper=A.DivideOp, right=exp2, pos=exp1left:pos})
   | exp AND exp                        (A.IfExp{test=exp1, then'=exp2, else'=SOME (A.IntExp 0), pos=exp1left})
   | exp OR exp                         (A.IfExp{test=exp1, then'=A.IntExp 1, else'=SOME exp2, pos=exp1left})
   | exp EQ exp                         (A.OpExp{left=exp1, oper=A.EqOp, right=exp2, pos=exp1left:pos})
   | exp NEQ exp                        (A.OpExp{left=exp1, oper=A.NeqOp, right=exp2, pos=exp1left:pos})
   | exp LT exp                         (A.OpExp{left=exp1, oper=A.LtOp, right=exp2, pos=exp1left:pos})
   | exp LE exp                         (A.OpExp{left=exp1, oper=A.LeOp, right=exp2, pos=exp1left:pos})
   | exp GT exp                         (A.OpExp{left=exp1, oper=A.GtOp, right=exp2, pos=exp1left:pos})
   | exp GE exp                         (A.OpExp{left=exp1, oper=A.GeOp, right=exp2, pos=exp1left:pos})
   | IF exp THEN exp                    (A.IfExp{test=exp1, then'=exp2, else'=NONE, pos=exp1left})
   | IF exp THEN exp ELSE exp           (A.IfExp{test=exp1, then'=exp2, else'=SOME(exp3), pos=exp1left})
   | NIL                                (A.NilExp)
   | LPAREN RPAREN                      (A.NilExp)
   | lvalue ASSIGN exp                  (A.AssignExp{var=lvalue1, exp=exp1, pos=lvalue1left})
   | BREAK                              (A.BreakExp BREAKleft)
   | WHILE exp DO exp                   (A.WhileExp{test=exp1, body=exp2,pos=exp1left})
   | MINUS exp %prec UMINUS             (A.OpExp{left=(A.IntExp 0), oper=A.MinusOp, right=exp1, pos=exp1left})
   | lvalue                             (A.var lvalue1)
   | ID LBRACK exp RBRACK OF exp        (A.ArrayExp {typ=ID1, size=exp1, init=exp2, pos=IDleft})
   | ID LBRACE flist RBRACE             () (* recCreate  *)
   | ID LPAREN funArgs RPAREN           (A.CallExp{func=ID, args=funArgs,pos=IDleft}) (* funCall *)
   | FOR ID ASSIGN exp TO exp DO exp    ()
   | LET decList IN exp END             ()
   | LET decList IN END                 ()

dec: tyDec                              ()
   | funDec                             ()
   | vardec                             ()
	 
decList: dec decList                    ()
       |                                ()

tyDec: TYPE ID EQ ty                    ()
	    
ty: ID                                  ()
  | arrty                               ()
  | recty                               ()
					
arrty: ARRAY OF ID                      ()
	     
recty: LBRACE fieldDec RBRACE           ()
     | LBRACE RBRACE                    ()

vardec: VAR ID COLON ID ASSIGN exp      ()
      | VAR ID ASSIGN exp               ()

fieldDec: fieldDec COMMA fieldDec       ()
        | ID COLON ID                   ()

funDec: FUNCTION ID LPAREN fieldDec RPAREN COLON ID EQ exp   ()
      | FUNCTION ID LPAREN RPAREN COLON ID EQ exp            ()
      | FUNCTION ID LPAREN fieldDec RPAREN EQ exp            ()
      | FUNCTION ID LPAREN RPAREN EQ exp                     ()

field: ID EQ exp                                             ()
     | field COMMA field                                     ()

flist: ID EQ exp flistTail                                   ()
     |                                                       ()
					    
flistTail: COMMA ID EQ exp flistTail                         ()
         |                                                   ()    
	    
funArgs: exp funArgsTail                                     (exp::funArgsTail)
       |                                                     ()

funArgsTail: COMMA exp funArgsTail                           (exp::funArgsTail)
           |                                                 ()
								 
lvalue: ID ltail                                             (A.SimpleVar(symbol ID, IDleft)::ltail)

(* This is the function notation Drew was talking about, idk... *)
	   
ltail: LBRACK exp RBRACK ltail                               (fn x => A.SubscriptVar(x, exp, IDleft))
     | DOT ID ltail                                          (fn x => A.FieldVar(x, symbol ID, IDleft))
     |                                                       ()
