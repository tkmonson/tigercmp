Step 1: write findEscapes to set escape variables in ASTs  (ANITA)
Step 2: Start creating structures Translate and Frame based on chapters 6 and 7 (SAUMYA)
Step 3: Modify FunEntry and VarEntry based on page 140, and modify Semant to use Translate as in chapter 6 (SAUMYA)
Step 4: Write unEx, unCx, unNx in Translate (TOMMY)
Step 5: Write a function in Translate to translate simple variables (this involves handling static links) (SAUMYA)

Step 6: Modify Semant to use the simplevar function in Translate
Step 7: Write functions in Translate to generate IR for all different kinds of Tiger exps
Step 8: Modify Semant to call Translate functions
Step 9: Do fragment stuff??




Ask: do we need an unCx(Nx _ ) pattern match?



Subscript Expressions:
If array base address is held in temp b, a[i] = MEM(BINOP(PLUS, MEM(b), BINOP(MUL, i, wordsize)))

Field expressions:
Similar to subscript expressions, but instead of an array index we need the offset of the field

Arithmetic:
Mostly simple. Not sure about unary complement.

Conditionals:
- Book says that every conditional translates to a Cx that takes 2 labels and generates a CJUMP
  -In an if statement, we can initialize the CJUMP with labels for the true/false cases
  -QUESTION: For a simple conditional (eg the Tiger program a<5), what labels do we use to initialize the CJUMP?
  -QUESTION: What to do specifically for an If statement where both expressions are Nx?
  -QUESTION: In the case that both are Cx, what is label z??

Variable definitions:
 - Should we generate Assign statements for each variable in AST,or in IR?

 While loops:
Given translatedBody and translatedTest, my guess is that we do
 Create labels: test, done
 SEQ(test, CJUMP(EQ, translatedTest, CONST 0, done, body), LABEL body, translatedBody, JUMP(NAME test, test::[]), done)
(QUESTION: Just have Drew look at this)

For loops:
Just translate to while loops and translate that
